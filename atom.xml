<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Song Ning&#39;s</title>
  <subtitle>有限的青春，无限的代码。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://songning.me/"/>
  <updated>2016-11-08T12:12:27.793Z</updated>
  <id>http://songning.me/</id>
  
  <author>
    <name>SongNing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android常用的adb命令</title>
    <link href="http://songning.me/2016/11/08/android-adb-command/"/>
    <id>http://songning.me/2016/11/08/android-adb-command/</id>
    <published>2016-11-08T09:30:47.000Z</published>
    <updated>2016-11-08T12:12:27.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>作为一个Android开发人员，了解常用的adb命令是很必要的。在使用adb命令前，我们先看一下环境有没有配置好。win+R输入cmd打开命令行工具输入adb，如果显示是这样：<br><a id="more"></a><br><img src="http://ofp4swv4i.bkt.clouddn.com/android-adb-command-succeed.png" alt="adb_succeed"></p>
<p>那么恭喜你，你的adb环境已经搭建好。</p>
<p>但是，如果显示是这样：</p>
<p><img src="http://ofp4swv4i.bkt.clouddn.com/android-adb-command-failure.png" alt="adb_failure"></p>
<p>那我们还需要对系统变量进行配置，就像配置jdk那样。</p>
<p>首先新建一个名叫<code>ANDROID_HOME</code>的系统变量，变量值填你的sdk的路径：</p>
<p><img src="http://ofp4swv4i.bkt.clouddn.com/android-adb-command-home.png" alt="adb_home"></p>
<p>然后点击系统的<code>Path</code>变量，编辑，在最后添加<code>;%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools</code>，记住前面有个英文的分号。</p>
<p>其实直接在<code>Path</code>里面添加<code>sdk</code>的<code>tools</code>文件夹路径和<code>platform-tools</code>也是可以配置好环境的，但是不推荐那个。为什么推荐新建一个<code>ANDROID_HOME</code>的系统变量呢？因为一个是方便以后换SDK的路径，另一个是React Native开发环境必须要<code>ANDROID_HOME</code>系统变量，只能识别这个。如果你以后想搭建React Native开发环境的时候，就不用配置这个了~</p>
<p>然后点击确定，确定，确定退出。这时候在在命令行工具输入adb就能看到上面第一张图片的那样了。到这就环境配置成功啦！</p>
<h2 id="命令表"><a href="#命令表" class="headerlink" title="命令表"></a>命令表</h2><p>以下表格是一些常用的命令：</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">adb</td>
<td style="text-align:center">adb是否安装成功？</td>
</tr>
<tr>
<td style="text-align:center">adb install xxx.apk 或 adb install -r xxx.apk</td>
<td style="text-align:center">安装APK(如果加 -r 参数，保留已设定数据，重新安装filename.apk)</td>
</tr>
<tr>
<td style="text-align:center">adb uninstall xxx.apk 或 adb uninstall -k xxx.apk</td>
<td style="text-align:center">卸载APK(如果加 -k 参数，为卸载软件但是保留配置和缓存文件)</td>
</tr>
<tr>
<td style="text-align:center">adb devices</td>
<td style="text-align:center">查看当前所有连接的模拟器设备</td>
</tr>
<tr>
<td style="text-align:center">adb -s 模拟器编号 命令</td>
<td style="text-align:center">对某一模拟器操作</td>
</tr>
<tr>
<td style="text-align:center">adb push 文件 模拟器路径</td>
<td style="text-align:center">导入文件到模拟器 （该命令也可以实现安装APK，只要把APK导入到”/system/app”或者”/data/app”就OK）</td>
</tr>
<tr>
<td style="text-align:center">adb pull 模拟器文件 本地路径</td>
<td style="text-align:center">从模拟器导出文件</td>
</tr>
<tr>
<td style="text-align:center">adb logcat</td>
<td style="text-align:center">查看模拟器log信息</td>
</tr>
<tr>
<td style="text-align:center">adb root</td>
<td style="text-align:center">获取管理员权限</td>
</tr>
<tr>
<td style="text-align:center">adb shell</td>
<td style="text-align:center">进入shell模式</td>
</tr>
<tr>
<td style="text-align:center">adb shell am start -n 包名/包名＋类名（-n 类名,-a action,-d date,-m MIME-TYPE,-c category,-e 扩展数据,等）</td>
<td style="text-align:center">启动activity (adb shell后面跟的命令主要来自源码\system\core\toolbox目录和源码\frameworks\base\cmds目录)</td>
</tr>
<tr>
<td style="text-align:center">adb get-serialno</td>
<td style="text-align:center">获取设备ID号</td>
</tr>
<tr>
<td style="text-align:center">adb start-server</td>
<td style="text-align:center">开启adb服务</td>
</tr>
<tr>
<td style="text-align:center">adb kill-server</td>
<td style="text-align:center">关闭adb服务</td>
</tr>
<tr>
<td style="text-align:center">adb shell sqlite3</td>
<td style="text-align:center">访问sqlite3</td>
</tr>
<tr>
<td style="text-align:center">adb reboot</td>
<td style="text-align:center">重启设备</td>
</tr>
<tr>
<td style="text-align:center">adb remount</td>
<td style="text-align:center">挂在分区(可使系统分区重新可写)</td>
</tr>
<tr>
<td style="text-align:center">adb forward tcp:5555 tcp:8000</td>
<td style="text-align:center">发布端口（可以设置任意的端口号，做为主机向模拟器或设备的请求端口）</td>
</tr>
<tr>
<td style="text-align:center">adb shell reboot -p</td>
<td style="text-align:center">关机命令</td>
</tr>
</tbody>
</table>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>不定期更新，敬请关注~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;作为一个Android开发人员，了解常用的adb命令是很必要的。在使用adb命令前，我们先看一下环境有没有配置好。win+R输入cmd打开命令行工具输入adb，如果显示是这样：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://songning.me/categories/Android/"/>
    
    
      <category term="备忘" scheme="http://songning.me/tags/%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title>Google官方MVP框架源码解读</title>
    <link href="http://songning.me/2016/11/03/google-rxjava-mvp/"/>
    <id>http://songning.me/2016/11/03/google-rxjava-mvp/</id>
    <published>2016-11-03T07:54:41.000Z</published>
    <updated>2016-11-05T06:17:56.640Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看关于MVP框架的封装，于是网上搜了一下，发现了<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">谷歌官方的MVP Demo</a>，发现还是Google的看着顺眼。于是就对其分析了一下。Google的MVP版本很多，不过思想都一样，所以就拿<a id="more"></a>当前较火的RxJava那个MVP版本进行分析。</p>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><p>首先我们来看一下整个工程里面的包的结构：</p>
<p><img src="http://ofp4swv4i.bkt.clouddn.com/google-rxjava-mvp-main.png" alt="工程结构"></p>
<p>整个工程结构不难，除了data层是处理数据外，其他都是按功能分模块。</p>
<h2 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h2><p>我们挑其中的一个addedittask模块来看，可以看到里面有个叫AddEditTaskContract的类，这个类是干嘛用的呢？ 这就是和普通的MVP结构不同的地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddEditTaskContract</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span> <span class="keyword">extends</span> <span class="title">BaseView</span>&lt;<span class="title">Presenter</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showEmptyTaskError</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTasksList</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">saveTask</span><span class="params">(String title, String description)</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">populateTask</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Contract字面意思是契约，这个契约类的作用是把View层和Presenter层的接口包装起来，方便管理，同时也减少了接口文件的数量。BaseView传了个Presenter的泛型进去，我们接下来看看BaseView和BasePresenter:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(T presenter)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BaseView中只有一个方法setPresenter，这个方法的作用是获取Presenter对象，方便在View层使用（如在Activity和Fragment中）。看见BasePresenter中的两个方法，是不是就想到了RxJava里的订阅和解除订阅？没错，在这里还真的是这个意思。</p>
<p>下面，就开始介绍它们的实现类了~ </p>
<h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><h3 id="Presenter实现类"><a href="#Presenter实现类" class="headerlink" title="Presenter实现类"></a>Presenter实现类</h3><p>首先是实现了AddEditTaskContract.Presenter接口的AddEditTaskPresenter类，先看参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TasksDataSource mTasksRepository;</div><div class="line"></div><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AddEditTaskContract.View mAddTaskView;</div><div class="line"></div><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BaseSchedulerProvider mSchedulerProvider;</div><div class="line"></div><div class="line"><span class="meta">@Nullable</span></div><div class="line"><span class="keyword">private</span> String mTaskId;</div><div class="line"></div><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="keyword">private</span> CompositeSubscription mSubscriptions;</div></pre></td></tr></table></figure>
<p>其中TasksDataSource是数据源，AddEditTaskContract.View是View对象，BaseSchedulerProvider是订阅提供者（用于线程切换），CompositeSubscription可以理解为RxJava的订阅管理者，在适当的时候解除订阅防止内存泄漏。</p>
<p>然后看构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AddEditTaskPresenter</span><span class="params">(@Nullable String taskId,</span></span></div><div class="line">                            @NonNull TasksDataSource tasksRepository,</div><div class="line">                            @NonNull AddEditTaskContract.View addTaskView,</div><div class="line">                            @NonNull BaseSchedulerProvider schedulerProvider) &#123;</div><div class="line">    mTaskId = taskId;</div><div class="line">    mTasksRepository = checkNotNull(tasksRepository, <span class="string">"tasksRepository cannot be null!"</span>);</div><div class="line">    mAddTaskView = checkNotNull(addTaskView, <span class="string">"addTaskView cannot be null!"</span>);</div><div class="line">    mSchedulerProvider = checkNotNull(schedulerProvider, <span class="string">"schedulerProvider cannot be null!"</span>);</div><div class="line"></div><div class="line">    mSubscriptions = <span class="keyword">new</span> CompositeSubscription();</div><div class="line">    mAddTaskView.setPresenter(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造方法传进来了三个主要的参数，同时初始化了CompositeSubscription。注意看，上面BaseView中提到的setPresenter方法在这里用到了，就是获取当前对象，也就是Presenter对象。至于构造方法中传进来的对象怎么来的，我们等下在View层会详细讲。</p>
<p>剩下的就是接口实现的方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mTaskId != <span class="keyword">null</span>) &#123;</div><div class="line">        populateTask();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span> </span>&#123;</div><div class="line">    mSubscriptions.clear();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 省略部分代码</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mTaskId == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"populateTask() was called but task is new."</span>);</div><div class="line">    &#125;</div><div class="line">    Subscription subscription = mTasksRepository</div><div class="line">            .getTask(mTaskId)</div><div class="line">            .subscribeOn(mSchedulerProvider.computation())</div><div class="line">            .observeOn(mSchedulerProvider.ui())</div><div class="line">            .subscribe(<span class="keyword">new</span> Observer&lt;Task&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (mAddTaskView.isActive()) &#123;</div><div class="line">                        mAddTaskView.showEmptyTaskError();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Task task)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (mAddTaskView.isActive()) &#123;</div><div class="line">                        mAddTaskView.setTitle(task.getTitle());</div><div class="line">                        mAddTaskView.setDescription(task.getDescription());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">    mSubscriptions.add(subscription);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们主要看subscribe、unsubscribe和populateTask方法。在subscribe方法中进行初始化数据，调用了populateTask方法添加订阅和获取数据。unsubscribe方法中进行解除订阅。在populateTask方法中，返回数据的地方调用了View的接口，将数据传给View层。至此，整个Presenter算是讲完啦。我们接下来看到View层，也就是Activity或者Fragment。</p>
<h3 id="View实现类"><a href="#View实现类" class="headerlink" title="View实现类"></a>View实现类</h3><p>先看代码，下面的代码我们只看重要的部分，所以省略了很多，想看完整的可以下载<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-rxjava/" target="_blank" rel="external">Google官方完整的代码</a>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEditTaskFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span></span></div><div class="line">        <span class="keyword">implements</span> <span class="title">AddEditTaskContract</span>.<span class="title">View</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AddEditTaskContract.Presenter mPresenter;</div><div class="line"></div><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onResume();</div><div class="line">        mPresenter.subscribe();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPause();</div><div class="line">        mPresenter.unsubscribe();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(@NonNull AddEditTaskContract.Presenter presenter)</span> </span>&#123;</div><div class="line">        mPresenter = checkNotNull(presenter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showEmptyTaskError</span><span class="params">()</span> </span>&#123;</div><div class="line">        Snackbar.make(mTitle, getString(R.string.empty_task_message), Snackbar.LENGTH_LONG).show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTasksList</span><span class="params">()</span> </span>&#123;</div><div class="line">        getActivity().setResult(Activity.RESULT_OK);</div><div class="line">        getActivity().finish();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</div><div class="line">        mTitle.setText(title);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</div><div class="line">        mDescription.setText(description);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> isAdded();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，AddEditTaskFragment实现了AddEditTaskContract.View接口。然后在onResume和onPause这两个关系生命周期的地方进行了和Presenter的绑定（防止内存泄漏），在setPresenter方法中获取Presenter实例。再看下面一堆的View接口中定义的方法，就是得到数据后用来进行界面操作了啦~</p>
<h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>上面说到AddEditTaskPresenter的构造方法中的参数怎么来的，因为是RxJava的MVP版本，就顺带说一下吧。因为整个工程是多Activity+多Fragment的结构，其实是在Activity中创建了Fragment对象，然后添加到布局中的。我们看一下AddEditTaskActivity的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEditTaskActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_ADD_TASK = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.addtask_act);</div><div class="line"></div><div class="line">        <span class="comment">/*...*/</span></div><div class="line"></div><div class="line">        AddEditTaskFragment addEditTaskFragment =</div><div class="line">                (AddEditTaskFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);</div><div class="line"></div><div class="line">        String taskId = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (addEditTaskFragment == <span class="keyword">null</span>) &#123;</div><div class="line">            addEditTaskFragment = AddEditTaskFragment.newInstance();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (getIntent().hasExtra(AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID)) &#123;</div><div class="line">                taskId = getIntent().getStringExtra(</div><div class="line">                        AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID);</div><div class="line">                actionBar.setTitle(R.string.edit_task);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                actionBar.setTitle(R.string.add_task);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ActivityUtils.addFragmentToActivity(getSupportFragmentManager(),</div><div class="line">                    addEditTaskFragment, R.id.contentFrame);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Create the presenter</span></div><div class="line">        <span class="keyword">new</span> AddEditTaskPresenter(</div><div class="line">                taskId,</div><div class="line">                Injection.provideTasksRepository(getApplicationContext()),</div><div class="line">                addEditTaskFragment,</div><div class="line">                Injection.provideSchedulerProvider());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建了AddEditTaskFragment对象，然后添加到布局中。最后new了一个AddEditTaskPresenter，这才是重点。到这里，不禁有一个问题，AddEditTaskPresenter构造方法的第二个和第四个参数是哪来的？我们再看Injection类就知道了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Injection</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TasksRepository <span class="title">provideTasksRepository</span><span class="params">(@NonNull Context context)</span> </span>&#123;</div><div class="line">        checkNotNull(context);</div><div class="line">        <span class="keyword">return</span> TasksRepository.getInstance(FakeTasksRemoteDataSource.getInstance(),</div><div class="line">                TasksLocalDataSource.getInstance(context, provideSchedulerProvider()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BaseSchedulerProvider <span class="title">provideSchedulerProvider</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SchedulerProvider.getInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>文章都快看完了，都说MVP，Model层在哪里呢？看上面代码中的provideTasksRepository方法，其实这就相当于Model层，获取到数据后传给Presenter，只不过用了一个数据源的名字，功能都一样。provideSchedulerProvider方法是获取一个RxJava的线程调度器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerProvider</span> <span class="keyword">implements</span> <span class="title">BaseSchedulerProvider</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SchedulerProvider INSTANCE;</div><div class="line"></div><div class="line">    <span class="comment">// Prevent direct instantiation.</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SchedulerProvider</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SchedulerProvider <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</div><div class="line">            INSTANCE = <span class="keyword">new</span> SchedulerProvider();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Scheduler <span class="title">computation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Schedulers.computation();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Scheduler <span class="title">io</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Schedulers.io();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Scheduler <span class="title">ui</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> AndroidSchedulers.mainThread();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类用了懒汉式获取单例（看源码还是有收获的^_^），实现了BaseSchedulerProvider接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseSchedulerProvider</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="function">Scheduler <span class="title">computation</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="function">Scheduler <span class="title">io</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="function">Scheduler <span class="title">ui</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一共三个线程，计算线程、IO线程、UI线程，完成了对RxJava线程管理的封装使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次解读，收益良多。目前来说，MVP确实是个好框架，而且RxJava便捷的线程切换对于在Model层中进行IO操作和Presenter层的UI操作的支持，两者简直是天生一对。</p>
<p>对于Google官方MVP框架的源码解读到这就结束啦，下一篇将对MVP进行封装一下，让这个框架更加实用，同时简化操作，少写代码。敬请期待~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看关于MVP框架的封装，于是网上搜了一下，发现了&lt;a href=&quot;https://github.com/googlesamples/android-architecture&quot;&gt;谷歌官方的MVP Demo&lt;/a&gt;，发现还是Google的看着顺眼。于是就对其分析了一下。Google的MVP版本很多，不过思想都一样，所以就拿
    
    </summary>
    
      <category term="Android" scheme="http://songning.me/categories/Android/"/>
    
    
      <category term="MVP" scheme="http://songning.me/tags/MVP/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式 - 单例模式</title>
    <link href="http://songning.me/2016/10/29/singleton-pattern/"/>
    <id>http://songning.me/2016/10/29/singleton-pattern/</id>
    <published>2016-10-29T09:19:04.000Z</published>
    <updated>2016-10-30T07:11:25.782Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是一种很常见的设计模式，我们在各种第三方库的源码中经常可以看见它的身影。单例的本质是控制实例的数量，全局有且只有一个对象，并且能够全局访问。虽然它很“小”，但作用却很大。<a id="more"></a>例如可以节约系统内存资源，防止一些不必要的操作。 但凡做Java相关的编程工作，都应该要了解Java中的单例是怎么写的，常见的有几种写法，特点是什么。常见的有下面几种：</p>
<h2 id="常见写法"><a href="#常见写法" class="headerlink" title="常见写法"></a>常见写法</h2><p>这应该是最简单的写法，也叫懒汉式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton mInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            mInstance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这种写法有一个问题就是当多个线程同时调用getInstance方法的时候，就会产生多个实例，这样线程就会变得不安全了。</p>
<p>既然存在多个线程同时调用这个问题，所以我们会想到synchronized关键字似乎可以解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton mInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            mInstance = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>synchronized同步锁可以保证这个方法只能同时被一个线程占有，这样看来好像是可以防止多个线程同时调用而产生多个实例这个问题，但是也有副作用。我们的目的其实只是在第一个初始化mInstance的时候需要锁上，而后面取用mInstance的时候，根本不需要线程同步。上面的写法是每次调用getInstance获取实例的时候都会进行同步锁检查，这无疑降低了效率，同时增加了资源的消耗。</p>
<h2 id="双重检查锁写法"><a href="#双重检查锁写法" class="headerlink" title="双重检查锁写法"></a>双重检查锁写法</h2><p>既然上面的写法在每次getInstance的时候都检查锁，降低了效率消耗了大量资源。于是就产生了双重检查锁写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton mInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//保证了同一时间只能只能有一个对象访问此同步块        </span></div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                    mInstance = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只需要同步初始化mInstance的那部分代码，这样看起来好像可以了。但是，整个流程是这样的，首先给mInstance分配内存，然后调用构造方法进行初始化操作，最后才将mInstance对象指向分配的内存空间。要是初始化操作的时候花费了大量的时间，这里的顺序如果在此时被打断的话，那么mInstance对象将指向为完成初始化的mInstance的内存空间，这时就会报错了。这时，volatile关键字就登场了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//添加volatile关键字修饰</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton mInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//保证了同一时间只能只能有一个对象访问此同步块</span></div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                    mInstance = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的值，相当于自动发现最新值。volatile也相当于一个微型的锁，执行的顺序就不会被打乱了，mInstance对象也不会指向未完成初始化的mInstance的内存空间，最终完成单例模式的实现。</p>
<p>这种方法是比较推荐用的，很多开源库都是用这种方法，我用得最多的也是这种方法。</p>
<h2 id="饿汉式写法"><a href="#饿汉式写法" class="headerlink" title="饿汉式写法"></a>饿汉式写法</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton mInstance = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>饿汉式特点是提前实例化，没有懒汉式中多线程问题，但不管我们是不是调用getInstance方法都会存在一个实例在内存中。这样会延长类的加载时间，不能传递参数，并且占用资源，造成浪费。</p>
<h2 id="静态内部类写法"><a href="#静态内部类写法" class="headerlink" title="静态内部类写法"></a>静态内部类写法</h2><p>这是在<a href="http://item.jd.com/10058902.html" target="_blank" rel="external">《Effective Java》</a>中推荐的一种写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和饿汉式有点像，但是在类加载的时候并没有初始化，只是在调用getInstance方法的时候才会从静态内部类中加载。而且没有多线程的问题，也是一种推荐的写法。</p>
<h2 id="枚举写法"><a href="#枚举写法" class="headerlink" title="枚举写法"></a>枚举写法</h2><p>在<a href="http://item.jd.com/10058902.html" target="_blank" rel="external">《Effective Java》</a>中还看到了一种比较少见的写法，枚举：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</div><div class="line"></div><div class="line">    INSTANCE;</div><div class="line"></div><div class="line">    Singleton() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//do something...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Singleton.INSTANCE.doSomething();</div></pre></td></tr></table></figure>
<p>因为枚举的特性，保证了只有一个实例，而且自由序列化，线程安全。所以，也可以用枚举的方法写单例模式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们比较了几种常见的写法，最终推荐是用双重检查锁写法和静态内部类的写法。枚举虽然也可以，但是在Android开发中几乎没见过，而且Google的Android官网不建议使用enums，因为占用内存多。所以如果是Android开发，还是用双重检查锁写法或者静态内部类的写法吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式是一种很常见的设计模式，我们在各种第三方库的源码中经常可以看见它的身影。单例的本质是控制实例的数量，全局有且只有一个对象，并且能够全局访问。虽然它很“小”，但作用却很大。
    
    </summary>
    
      <category term="Java" scheme="http://songning.me/categories/Java/"/>
    
    
      <category term="基础" scheme="http://songning.me/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="http://songning.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Activity的四种启动模式</title>
    <link href="http://songning.me/2016/10/28/activity-launch-mode/"/>
    <id>http://songning.me/2016/10/28/activity-launch-mode/</id>
    <published>2016-10-28T13:06:30.000Z</published>
    <updated>2016-11-09T07:46:19.316Z</updated>
    
    <content type="html"><![CDATA[<p>因为要为了出去工作而准备面试了，所以有必要总结一下这一年多来学习Android的知识点，同时也能复习一下所学所得。有些虽然很基础，但有句老话叫“好记性不如烂笔头”。好了，废话不多说，就<a id="more"></a>从基本的Activity启动模式开始。</p>
<h2 id="设置Activity的启动模式"><a href="#设置Activity的启动模式" class="headerlink" title="设置Activity的启动模式"></a>设置Activity的启动模式</h2><p>怎么设置Activity的启动模式呢？有两种方法：</p>
<ol>
<li><p>在AndroidManifest.xml中，设置launchMode属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span></div><div class="line">    <span class="attr">android:label</span>=<span class="string">"@string/title_activity_second"</span></div><div class="line">    <span class="attr">android:launchMode</span>=<span class="string">"standard"</span></div><div class="line">    <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme.NoActionBar"</span>/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>在启动Activity的时候，设置setFlags：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent=<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,SecondActivity.class);</div><div class="line">intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>两种设置模式的方法还是有区别的，按照惯例Java代码中的优先级肯定高于xml代码中的，如果两种都存在的话，以Java代码中的为准。另外在AndroidManifest.xml中无法设置FLAG_ACTIVITY_CLEAR_TOP标识，在Java代码中无法指定singleInstance模式。</p>
<h2 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式"></a>四种模式</h2><h3 id="standard：标准模式"><a href="#standard：标准模式" class="headerlink" title="standard：标准模式"></a>standard：标准模式</h3><p>系统的默认模式，如果你没有设置启动模式的话就是这个模式。标准模式下的特点是每启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。被创建的Activity实例的生命周期正常调用，也就是onCreate、onStart、onResume都会被调用。</p>
<p>在这种模式下，当我们多次启动同一个Activity的时候，系统就会创建多个实例并把他们一一放到任务栈中。任务栈是一种后进先出的结构，每当我们按一下返回键的时候，就会有一个Activity出栈。另外我发现微信有很多功能都是快速点击的话会创建多个Activity，比如快速点击两下朋友圈，就会创建两个朋友圈的Activity，我不知道这是微信有意为之还是程序员疏忽了这些细节问题。</p>
<p>在<a href="http://item.jd.com/11760209.html" target="_blank" rel="external">《Android开发艺术探索》</a>提到，如果用ApplicationContext去启动一个Activity的话，会报错。像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent=<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,SecondActivity.class);</div><div class="line">App.getContext().startActivity(intent);</div></pre></td></tr></table></figure>
<p>我试了下果然报了这个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity  context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</div></pre></td></tr></table></figure>
<p>这是因为standard模式下的Activity会默认进入启动它的Activity所属的任务栈，但是直接用ApplicationContext去启动它的话并没有所谓的任务栈，所以报错了。解决这个问题的方法是为待启动的Activity一个标记位FLAG_ACTIVITY_NEW_TASK：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent=<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,SecondActivity.class);</div><div class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class="line">App.getContext().startActivity(intent);</div></pre></td></tr></table></figure>
<p>这样就可以正常启动了，这时系统为它创建了一个新的任务栈，并且是以standard模式启动的。</p>
<h3 id="singleTop：栈顶复用模式"><a href="#singleTop：栈顶复用模式" class="headerlink" title="singleTop：栈顶复用模式"></a>singleTop：栈顶复用模式</h3><p>这种模式下，待启动的Activity如果位于任务栈的栈顶，那么就不会新建这个Activity的实例了。同时它的onNewIntent方法会被调用，我们可以在此方法取出当前请求信息。要注意的是，这个Activity的onCreate和onStart方法并不会被系统调用，因为它并没有发生改变。</p>
<p>另外一种情况是，当这个Activity并不在任务栈的栈顶，这样的话新的Activity就会被以新实例的方式创建，onCreate、onStart、onResume都会被调用。</p>
<h3 id="singleTask：栈内复用模式"><a href="#singleTask：栈内复用模式" class="headerlink" title="singleTask：栈内复用模式"></a>singleTask：栈内复用模式</h3><p>这种模式下，相当于单例模式。单例模式相信大家都懂，单例模式就是要确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<p>Activity被创建出来，肯定需要一个任务栈，singleTask模式下启动此Activity首先需要判断有没有此Activity想要的任务栈，如果不存在就创建一个任务栈，并将此Activity压到栈中。如果任务栈已经存在，并且任务栈中也存在此Activity的实例，系统就会将此Activity调到栈顶，显示出来。也就是说，待启动的Activity在任务栈中如果已经存在，无论你启动多少次这个Activity都不会创建新的实例了，此时也会只调用onNewIntent方法。</p>
<h3 id="singleInstance：单实例模式"><a href="#singleInstance：单实例模式" class="headerlink" title="singleInstance：单实例模式"></a>singleInstance：单实例模式</h3><p>这个模式可以理解为singleTask模式的加强版。此模式除了拥有singleTask模式所以的特性外，还有一点就是此模式的Activity只能单独的存在于一个任务栈中，由于栈内复用的特性，所以后续的请求均不会创建新的Activity实例了，除非这个任务栈被系统销毁了。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>标准模式，这个就不用多说了吧。</p>
<h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>适合接收通知启动的内容显示页面。</p>
<p>例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。</p>
<h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>适合作为程序入口点。</p>
<p>例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent方法，并且会清空主界面上面的其他页面。</p>
<p>多处判断弹出登录界面。</p>
<p>应用里面经常要根据服务器返回的用户登录状态来判断用户是否还在线，是否需要重新登录。但是当多个接口同时请求的时候，如果你的处理方式都是非在线状态下就会弹出登录的Activity，就会弹出很多个登录的Activity，用户体验很差。这时你可以将登录的Activity的launchMode设置为singleTask，就不会弹出多个同样的登录Activity了。然后就可以放心的在每个判断用户在线的地方启动登录的Activity了。</p>
<h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>闹铃的响铃界面。</p>
<p>你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面，在上午5点59分时，你在微信和朋友聊天，在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以SingleInstance加载模式打开的)，你按返回键，回到的是微信的聊天界面。这是因为 AlarmAlertActivity所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以SingleTask打开AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>关于Activity的四种启动模式介绍到此完毕~欢迎补充！另外有不足的地方，欢迎在下方评论，交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为要为了出去工作而准备面试了，所以有必要总结一下这一年多来学习Android的知识点，同时也能复习一下所学所得。有些虽然很基础，但有句老话叫“好记性不如烂笔头”。好了，废话不多说，就
    
    </summary>
    
      <category term="Android" scheme="http://songning.me/categories/Android/"/>
    
    
      <category term="基础" scheme="http://songning.me/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="http://songning.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>第一章</title>
    <link href="http://songning.me/2016/10/27/first/"/>
    <id>http://songning.me/2016/10/27/first/</id>
    <published>2016-10-27T12:21:04.000Z</published>
    <updated>2016-10-27T13:43:09.284Z</updated>
    
    <content type="html"><![CDATA[<p>花了一天时间，博客算是完全搭建好了。其实也没想象中的那么难，只要你爱折腾。作为一个编程人，捣鼓一个个人博客是很有必要的。为什么这么说呢，因为在捣鼓过程中，你会接触很多命令行操<a id="more"></a>作，你会觉得x格满满，然后自信心爆棚。等下我要去阅读Android源码了，还写什么博客。哈哈，开个玩笑。 </p>
<p>其实，我觉得这样简洁的环境下，更能够让人保持清醒的头脑。我想，Markdown语法可能也有这么一个设计初衷吧。一个黑白的界面，一个MarkdownPad2，两个命令行，就可以将自己的成果与别人分享…可以写博客的地方很多，例如CSDN、简书等。但是那些地方多数繁杂，不是我想要的。</p>
<p>之所以这么顺利的搭建好这个博客，我觉得应该是因为Hexo是基于Node.js，前段时间刚好学习了一下当前比较火的React Native，一个也是基于Node.js的开源框架，用于同时写Android端和iOS应用。所以对于npm命令还是很熟悉的，之后就是按照网上的教程，一步一步照着做就好了。</p>
<p>博客的意义不在于装x，更重要的是作为一个技术博客，应该要与别人分享我们发现的“新大陆”。交流也是很重要的一部分，要是哪位小伙伴愿意一起共同学习，可以联系我添加友情链接^_^</p>
<p>大四了，马上要毕业，要开始准备面试了…嗯，第一篇博客，就这样。开始了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;花了一天时间，博客算是完全搭建好了。其实也没想象中的那么难，只要你爱折腾。作为一个编程人，捣鼓一个个人博客是很有必要的。为什么这么说呢，因为在捣鼓过程中，你会接触很多命令行操
    
    </summary>
    
      <category term="随想" scheme="http://songning.me/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="http://songning.me/tags/%E9%9A%8F%E6%83%B3/"/>
    
      <category term="第一篇" scheme="http://songning.me/tags/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://songning.me/2016/10/26/hello-world/"/>
    <id>http://songning.me/2016/10/26/hello-world/</id>
    <published>2016-10-26T09:49:30.311Z</published>
    <updated>2016-10-27T12:35:58.214Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
